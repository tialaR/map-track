# üìò ADR Official Guideline

---

## ‚úÖ Status

- **ADR:** 002
- **Version:** v1.0
- **State:** Accepted
- **Scope:** Code Readability, Explicit Logic, Conditionals, React Naming
- **Supersedes:** ‚Äî
- **Superseded by:** ‚Äî

---

## Context

Poorly written conditionals are one of the **biggest sources of accidental complexity** in code.

Each `if`, `else`, ternary operator, or negation:

- opens **new execution paths**
- creates **parallel timelines** in the code
- makes code difficult to read, maintain, and refactor

This guide defines **clear rules** for writing conditionals and function names in MapTrack, prioritizing:

- readability
- predictability
- linear code readability

---

## 1Ô∏è‚É£ Rules in Conditionals (`if`)

> Objective: to write conditionals that can be read without mentally executing the code.

---

### 1.1 Avoid negations in `if`

### ‚ùå Wrong

```tsx
if (!isUserAuthenticated) {
  redirectUserToLogin();
  return;
}
```

### ‚ùå Wrong

```tsx
if (isUserAuthenticated === false) {
  redirectUserToLogin();
  return;
}
```

### ‚úÖ Correct

```tsx
const isUserUnauthenticated = isUserAuthenticated === false;

if (isUserUnauthenticated) {
  redirectUserToLogin();
  return;
}
```

### Why?

1. Negations make reading difficult
2. They force double mental interpretation
3. They scale poorly in complex rules
4. Code should be read in an affirmative way

### Rule

> Conditionals should NOT use negation (!)
> Prefer to encapsulate conditionals in auxiliary variables with affirmative names

---

### 1.2 Early Return > Else (Without Negation)

‚ö†Ô∏è **Early return is the default pattern in MapTrack.**

### ‚ùå Wrong (else)

```tsx
if (isUserProfileValid) {
  saveUserProfile();
} else {
  showError();
}
```

### ‚ùå Wrong (early return with negation)

```tsx
if (!isUserProfileValid) {
  showError();
  return;
}

saveUserProfile();
```

### ‚úÖ Correct (early return without negation)

```tsx
const isUserProfileInvalid = isUserProfileValid === false;

if (isUserProfileInvalid) {
  showError();
  return;
}

saveUserProfile();
```

### Why?

- Early return maintains linear flow
- Eliminates `else` blocks
- Facilitates future extension
- Preserves clear semantics

### Rule

> Use early return whenever possible, without negation in the if statement
> `else` is only allowed when the semantics become clearer with it (example: nested conditionals)

---

### 1.3 Avoid nested conditionals

Each `if` inside another creates **a new timeline** in the code.

### ‚ùå Wrong (nested)

```tsx
if (user) {
  if (user.isAdmin) {
    if (user.isActive) {
      allowUserAccessAdminPanel();
    }
  }
}
```

### ‚ùå Wrong (complex ternary)

```tsx
user && user.isAdmin && user.isActive ? allowUserAccessAdminPanel() : null;
```

### ‚úÖ Correct (isolated rule without negation)

```tsx
const isUserActive = user && user.isActive;
const isActiveUserAdmin = isUserActive && user.isAdmin;
const shouldBlockUserAccessAdminPanel = isActiveUserAdmin === false;

if (shouldBlockUserAccessAdminPanel) return;

allowUserAccessAdminPanel();
```

_(to avoid `!`, we must maintain consistency)_

```tsx
const shouldBlockAccess = !(user && user.isAdmin && user.isActive);

if (shouldBlockAccess) return;

allowAdminPanelAccess();
```

### Why?

1. Nested conditionals explode complexity
2. They make reading and testing difficult
3. They hide business rules
4. Each `if` opens a new possible path

### Rule

> Never write an if inside another if
> Extract the rule to a variable or function

---

### 1.4 Ternary Statements vs. `if`

### ‚ùå Incorrect

```tsx
const label = isAdmin
  ? isActive
    ? "Active Admin"
    : "Inactive Admin"
  : "Regular User";
```

### ‚úÖ Correct

```tsx
const isActiveUserAdmin = isUserAdmin && isUserActive;
const isInactiveUserAdmin = isActiveUserAdmin === false;

if (isActiveUserAdmin) {
  return "Active Admin";
}

if (isInactiveUserAdmin) {
  return "Inactive Admin";
}

return "Regular User";
```

### Rule

> Ternary statements are only allowed for simple decisions
> More than one condition ‚Üí use `if`

---

## 2Ô∏è‚É£ Functions and Events in React ‚Äî `handle` vs `on`

### Context

In React, it's essential to distinguish between:

- **internal component** functions
- **functions received via props**
- **auxiliary or domain** functions

---

### 2.1 `handle*` ‚Äî Internal event handlers

Used for functions:

- Defined inside the component
- Triggered by user interaction

### ‚úÖ Correct

```tsx
function handleSubmitForm() {}
function handleClickMarker() {}
```

---

### 2.2 `on*` ‚Äî External callbacks or effects

Used for functions:

- Received via props
- Represent actions, side effects, API calls, or calculations

### ‚úÖ Correct

```tsx
function onCreateMarker() {}
function onSaveCampaign() {}
function onFetchMapData() {}
```

### Why?

This prevents confusion during reading, review, and debugging

---

### Rule

| Function Type               | Prefix                                            |
| --------------------------- | ------------------------------------------------- |
| User Event (internal)       | `handle*`                                         |
| Callback by props / action  | `on*`                                             |
| Rule / calculation / domain | explicit verb (`calculate`, `validate`, `format`) |

---

## 3Ô∏è‚É£ Components vs Behavior (React Rule)

- UI state belongs to the component
- Side effects belong to hooks or services
- Hooks only exist when there is reactivity

**`*useState` in a component is perfectly valid when:\***

1. The state is purely UI-specific
2. does not represent business logic
3. does not need to be reused
4. does not affect other parts of the application

**_Where does the `hook` come in then?_**

1. When there is a side effect + orchestration
2. If there is no React state or reactive effect ‚Üí it is NOT a hook
3. Don't create hooks that simply encapsulate functions
4. The hook is not a useless wrapper

### üìÅ Structure Example

```
modules/
  user/
    services/
      userApi.ts
    hooks/
      useCreateUser.ts
    components/
      UserForm.tsx
```

---

### Service as a side effect example (talks to the server)

```tsx
// modules/user/services/userApi.ts
export async function createUserOnServer(payload: { name: string }) {
  await fetch("/api/users", {
    method: "POST",
    body: JSON.stringify(payload),
  });
}
```

---

### Hook (state + side effect)

```tsx
// modules/user/hooks/useCreateUser.ts
import { useState } from "react";
import { createUserOnServer } from "@/modules/user/services/userApi.ts";

export function useCreateUser() {
  const [isSubmitting, setIsSubmitting] = useState(false);

  async function submitUserProfile(userName: string) {
    setIsSubmitting(true);

    await createUserOnServer({ name: userName });

    setIsSubmitting(false);
  }

  return {
    submitUserProfile,
    isSubmitting,
  };
}
```

---

### Component (UI + events)

```tsx
// modules/user/components/UserForm.tsx
import { useState } from "react";
import { useCreateUser } from "@/modules/user/hooks/useCreateUser";

function UserForm() {
  const [userName, setUserName] = useState("");
  const { submitUserProfile, isSubmitting } = useCreateUser();

  function handleUserNameChange(event: React.ChangeEvent<HTMLInputElement>) {
    setUserName(event.target.value);
  }

  function handleFormSubmit(event: React.FormEvent<HTMLFormElement>) {
    event.preventDefault();
    submitUserProfile(userName);
  }

  return (
    <form onSubmit={handleFormSubmit}>
      <input value={userName} onChange={handleUserNameChange} />

      <button disabled={isSubmitting}>Save</button>
    </form>
  );
}
```

### Responsibilities must be clear

| Layer / Element              | Responsibility                                   |
| ---------------------------- | ------------------------------------------------ |
| `UserForm`                   | UI + UI state (ex: `useState`) + event binding   |
| `handle*`                    | Respond to user events (no business logic)       |
| `setUserName`                | Local UI state update                            |
| `useCreateUser`              | Orchestrate behavior + (ex: async flow )         |
| `submitUserProfile`          | Explicit business action                         |
| `userApi.createUserOnServer` | Explicit side effect (IO / server communication) |

```

```
