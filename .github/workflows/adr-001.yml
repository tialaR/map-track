name: ADR-001 Validation

on:
  pull_request:
    types: [opened, edited, synchronize, reopened]

jobs:
  adr-001:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint and capture output
        run: |
          npx eslint "src/**/*.{ts,tsx}" -f json -o eslint-report.json || true

      - name: ADR-001 Summary
        if: always()
        run: |
          echo "## ðŸ“˜ ADR-001 Validation Summary" >> $GITHUB_STEP_SUMMARY
          jq -r '.[] | select(.errorCount > 0) |
          "- âŒ " + .filePath + ": " + (.errorCount|tostring) + " error(s)"' eslint-report.json >> $GITHUB_STEP_SUMMARY

      - name: Comment ADR-001 violations
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");

            const report = JSON.parse(
              fs.readFileSync("eslint-report.json", "utf8")
            );

            const ruleDocs = {
              "local/no-obscure-function-names": "âŒ Obscure or non-semantic function name",
              "local/no-implicit-conditionals": "âŒ Implicit conditional logic",
              "local/no-magic-numbers": "âŒ Magic number detected",
              "local/no-side-effects-in-components": "âŒ Side effect inside React component",
              "local/no-negated-conditionals": "âŒ Negated conditional",
              "local/no-nested-conditionals": "âŒ Nested conditional logic",
              "local/no-fake-hooks": "âŒ Fake hook (no state or effect)",
              "local/react-event-naming": "âŒ Invalid React event naming"
            };

            const ruleToLabel = {
              "local/no-obscure-function-names": "adr-001:readability",
              "local/no-implicit-conditionals": "adr-001:logic",
              "local/no-negated-conditionals": "adr-001:logic",
              "local/no-nested-conditionals": "adr-001:logic",
              "local/no-magic-numbers": "adr-001:readability",
              "local/no-side-effects-in-components": "adr-001:architecture",
              "local/no-fake-hooks": "adr-001:architecture",
              "local/react-event-naming": "adr-001:naming"
            };

            const violatedRules = {};
            const labels = {};

            report.forEach(function (file) {
              file.messages.forEach(function (msg) {
                if (msg.ruleId && msg.ruleId.indexOf("local/") === 0) {
                  violatedRules[msg.ruleId] = true;

                  if (ruleToLabel[msg.ruleId]) {
                    labels[ruleToLabel[msg.ruleId]] = true;
                  }
                }
              });
            });

            const violatedRuleKeys = Object.keys(violatedRules);

            if (violatedRuleKeys.length === 0) {
              return;
            }

            let body =
              "âŒ **ADR-001 validation failed**\n\n" +
              "This Pull Request violates the following ADR-001 rules:\n\n";

            violatedRuleKeys.forEach(function (rule) {
              body += "- " + ruleDocs[rule] + "\n";
            });

            body +=
              "\nðŸ“˜ Refer to `docs/adr/ADR-001.md`\n" +
              "ðŸš« This PR is blocked until all violations are resolved.";

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

            const labelKeys = Object.keys(labels);

            if (labelKeys.length > 0) {
              github.rest.issues.addLabels({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: labelKeys
              });
            }
